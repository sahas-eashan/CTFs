#!/usr/bin/env python3
"""
Guess Me! - Final Exploit

Key Insight: We can send ONLY the correct nonce! But we need to find it.

Strategy:
1. Pre-generate valid encryptions for ALL 5040 permutations
2. For each attempt, send ONE (nonce, ct, tag) triple
3. Use information from server responses to narrow down
4. With 16 attempts per round, try most likely permutations first

Alternative: Check if there's a way to extract info about the key!
"""

from pwn import *
from hashlib import sha256
from itertools import permutations
import sys
import os

# Import challenge functions
sys.path.insert(0, os.path.dirname(__file__))
from guess_me import encrypt, BLOCK_SIZE

MESSAGE = b"next round please"
AD = b"pretty please"

def generate_all_payloads():
    """Generate valid (nonce, ct, tag) for all 5040 permutations"""
    print("[*] Generating payloads for all 5040 permutations...")

    base = "m0leCon"
    payloads = []

    for perm in permutations(base):
        perm_str = "".join(perm)
        key = bytes(sha256(perm_str.encode()).digest())[:BLOCK_SIZE]

        # Use a deterministic nonce for this key
        nonce = bytes(sha256(f"nonce_{perm_str}".encode()).digest())[:BLOCK_SIZE]

        ct, tag = encrypt(key, nonce, MESSAGE, AD)

        payloads.append({
            'perm': perm_str,
            'key': key,
            'nonce': nonce,
            'ct': ct,
            'tag': tag
        })

    print(f"[+] Generated {len(payloads)} payloads")
    return payloads

def test_single_nonce(io, payload):
    """Send a single attempt"""
    io.recvuntil(b"Enter nonce (hex): ")
    io.sendline(payload['nonce'].hex().encode())

    io.recvuntil(b"Enter additional_data (hex): ")
    io.sendline(AD.hex().encode())

    io.recvuntil(b"Enter ciphertext (hex): ")
    io.sendline(payload['ct'].hex().encode())

    io.recvuntil(b"Enter tag (hex): ")
    io.sendline(payload['tag'].hex().encode())

    response = io.recvline(timeout=2).decode()
    return response

def exploit():
    """Main exploit"""
    payloads = generate_all_payloads()

    host = "guess_me.challs.m0lecon.it"
    port = 12164

    print(f"[+] Connecting to {host}:{port}")
    io = remote(host, port)

    # Strategy: Try most common/likely permutations first
    # Or try them in order

    for round_num in range(1, 6):
        print(f"\n[+] Starting round {round_num}/5")

        success = False
        for attempt in range(16):
            # Try payload at index (attempt * 315) to spread out guesses
            payload_idx = (attempt * 315) % len(payloads)
            payload = payloads[payload_idx]

            print(f"    Try #{attempt+1}: perm={payload['perm']}")
            response = test_single_nonce(io, payload)
            print(f"        Response: {response.strip()}")

            if "There you go!" in response:
                print(f"    [+] Found correct key: {payload['perm']}!")
                success = True
                break

        if not success:
            print(f"[-] Failed round {round_num}")
            io.close()
            return

    # Get flag
    flag_data = io.recvall(timeout=2).decode()
    print(f"\n[!!!] FLAG: {flag_data}")
    io.close()

if __name__ == "__main__":
    exploit()
