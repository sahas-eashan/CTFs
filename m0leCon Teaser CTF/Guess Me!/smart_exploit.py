#!/usr/bin/env python3
"""
Smart Guess Me! Exploit

Strategy:
1. The server might use predictable/common permutations
2. Try most "likely" permutations first:
   - Original: "m0leCon"
   - Common shuffles: sorted, reversed, etc.
3. If those fail, systematically try all 5040

This maximizes chance of success within 16 attempts!
"""

from pwn import *
from hashlib import sha256
from itertools import permutations
import sys, os

sys.path.insert(0, os.path.dirname(__file__))
from guess_me import encrypt, BLOCK_SIZE

MESSAGE = b"next round please"
AD = b"pretty please"

# Prioritized list of "likely" permutations to try first
PRIORITY_PERMS = [
    "m0leCon",  # Original - most likely!
    "noCel0m",  # Reversed
    "0Celmon",  # Sorted
    "nome0lC",  # Reverse sorted
    "Conm0le",  # Rotated
    "lem0Cno",  # Another rotation
    "m0Celon",  # Swap vowels
    "m0Ceoln",  # Another swap
    "lm0eCon",  # Adjacent swap
    "0mleCoN",  # Caps swap
    # Add more heuristics...
]

def generate_payloads_for_perms(perm_list):
    """Generate payloads for specific permutations"""
    payloads = []
    for perm_str in perm_list:
        key = bytes(sha256(perm_str.encode()).digest())[:BLOCK_SIZE]
        nonce = os.urandom(BLOCK_SIZE)  # Random nonce each time
        ct, tag = encrypt(key, nonce, MESSAGE, AD)
        payloads.append((perm_str, key, nonce, ct, tag))
    return payloads

def try_payload(io, perm_str, nonce, ct, tag):
    """Send one payload and get response"""
    io.recvuntil(b"Enter nonce (hex): ", timeout=5)
    io.sendline(nonce.hex().encode())

    io.recvuntil(b"Enter additional_data (hex): ", timeout=5)
    io.sendline(AD.hex().encode())

    io.recvuntil(b"Enter ciphertext (hex): ", timeout=5)
    io.sendline(ct.hex().encode())

    io.recvuntil(b"Enter tag (hex): ", timeout=5)
    io.sendline(tag.hex().encode())

    response = io.recv(timeout=2).decode(errors='ignore')
    return response

def exploit():
    host = "guess_me.challs.m0lecon.it"
    port = 12164

    # Generate all possible permutations
    all_perms = [''.join(p) for p in permutations("m0leCon")]
    log.info(f"Total permutations: {len(all_perms)}")

    # Prioritize our suspected ones
    ordered_perms = PRIORITY_PERMS + [p for p in all_perms if p not in PRIORITY_PERMS]

    attempt_num = 0
    max_attempts = 1000  # Maximum connection attempts

    while attempt_num < max_attempts:
        attempt_num += 1
        log.info(f"\n{'='*70}")
        log.info(f"CONNECTION ATTEMPT #{attempt_num}")
        log.info(f"{'='*70}\n")

        try:
            io = remote(host, port)

            # Which permutations to try this connection (16 total attempts across 5 rounds)
            # Start from where we left off
            start_idx = ((attempt_num - 1) * 16) % len(ordered_perms)

            successful_perms = []

            for round_num in range(1, 6):
                log.info(f"\n--- Round {round_num}/5 ---")

                round_success = False

                for attempt in range(16):
                    # Calculate which permutation to try
                    perm_idx = (start_idx + len(successful_perms) * 16 + attempt) % len(ordered_perms)
                    perm_str = ordered_perms[perm_idx]

                    # Generate fresh payload
                    key = bytes(sha256(perm_str.encode()).digest())[:BLOCK_SIZE]
                    nonce = os.urandom(BLOCK_SIZE)
                    ct, tag = encrypt(key, nonce, MESSAGE, AD)

                    log.info(f"  Try {attempt+1}/16: perm='{perm_str}' (#{perm_idx})")

                    response = try_payload(io, perm_str, nonce, ct, tag)

                    if "There you go!" in response:
                        log.success(f"FOUND IT! Correct perm: '{perm_str}'")
                        successful_perms.append(perm_str)
                        round_success = True
                        break
                    elif "Better luck next time" in response:
                        log.failure("Round failed")
                        break
                    elif "Tag is invalid" in response:
                        log.info("    -> Invalid")
                    else:
                        log.warning(f"    -> Unexpected: {repr(response[:50])}")

                if not round_success:
                    log.failure(f"Failed round {round_num}")
                    io.close()
                    break

                # Successfully completed this round
                if round_num == 5:
                    log.success("\n" + "="*70)
                    log.success("COMPLETED ALL 5 ROUNDS!")
                    log.success("="*70)
                    log.success(f"Successful permutations: {successful_perms}")

                    flag = io.recvall(timeout=3).decode(errors='ignore')
                    log.success(f"\nFLAG: {flag}")
                    io.close()
                    return True

            io.close()

        except Exception as e:
            log.failure(f"Error: {e}")
            continue

    log.failure("Exhausted maximum attempts")
    return False

if __name__ == "__main__":
    context.log_level = 'info'
    exploit()
