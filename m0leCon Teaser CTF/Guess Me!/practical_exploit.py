#!/usr/bin/env python3
"""
Practical Guess Me! Exploit

Strategy:
1. Pre-generate all 5040 (nonce, ct, tag) tuples
2. Keep trying different permutations
3. If we fail a round, reconnect and try different perms
4. Eventually we'll luck into the right one within 16 tries

Also test if keys are persistent across rounds!
"""

from pwn import *
from hashlib import sha256
from itertools import permutations
import sys, os, random

sys.path.insert(0, os.path.dirname(__file__))
from guess_me import encrypt, BLOCK_SIZE

MESSAGE = b"next round please"
AD = b"pretty please"

def generate_all_payloads():
    """Generate (perm, key, nonce, ct, tag) for all 5040 permutations"""
    log.info("Generating 5040 payloads...")

    base = "m0leCon"
    payloads = []

    for perm in permutations(base):
        perm_str = "".join(perm)
        key = bytes(sha256(perm_str.encode()).digest())[:BLOCK_SIZE]
        nonce = bytes(sha256(f"n_{perm_str}".encode()).digest())[:BLOCK_SIZE]
        ct, tag = encrypt(key, nonce, MESSAGE, AD)

        payloads.append((perm_str, nonce, ct, tag))

    log.success(f"Generated {len(payloads)} payloads")
    return payloads

def try_payload(io, perm_str, nonce, ct, tag):
    """Try a single payload"""
    io.recvuntil(b"Enter nonce (hex): ", timeout=3)
    io.sendline(nonce.hex().encode())

    io.recvuntil(b"Enter additional_data (hex): ", timeout=3)
    io.sendline(AD.hex().encode())

    io.recvuntil(b"Enter ciphertext (hex): ", timeout=3)
    io.sendline(ct.hex().encode())

    io.recvuntil(b"Enter tag (hex): ", timeout=3)
    io.sendline(tag.hex().encode())

    response = io.recvline(timeout=2).decode(errors='ignore').strip()
    return response

def exploit_round(io, payloads, round_num, start_idx=0):
    """Try to complete one round"""
    log.info(f"Round {round_num}/5")

    for attempt in range(16):
        # Try payloads in a distributed manner
        idx = (start_idx + attempt * 315) % len(payloads)
        perm_str, nonce, ct, tag = payloads[idx]

        log.info(f"  Attempt {attempt+1}/16: Testing perm '{perm_str}'")

        try:
            response = try_payload(io, perm_str, nonce, ct, tag)
            log.info(f"    Response: {response}")

            if "There you go!" in response:
                log.success(f"Found correct key: {perm_str}!")
                return True, perm_str

            if "Better luck next time" in response:
                log.failure("Server ended the round")
                return False, None

        except EOFError:
            log.failure("Connection closed")
            return False, None
        except Exception as e:
            log.failure(f"Error: {e}")
            return False, None

    log.failure("Used all 16 attempts without success")
    return False, None

def main():
    host = "guess_me.challs.m0lecon.it"
    port = 12164

    payloads = generate_all_payloads()

    # Try multiple connection attempts with different starting points
    for attempt_num in range(100):  # Try up to 100 connections
        log.info(f"\n{'='*60}")
        log.info(f"Connection Attempt #{attempt_num+1}")
        log.info(f"{'='*60}\n")

        # Random starting point in the permutation space
        start_idx = random.randint(0, len(payloads)-1)

        try:
            io = remote(host, port)

            # Try to complete all 5 rounds
            successful_keys = []

            for round_num in range(1, 6):
                # If we found a key in previous round, try it again!
                if successful_keys:
                    log.info(f"Trying previous successful key: {successful_keys[-1]}")
                    # Find index of that key
                    for idx, (perm, _, _, _) in enumerate(payloads):
                        if perm == successful_keys[-1]:
                            start_idx = idx
                            break

                success, found_key = exploit_round(io, payloads, round_num, start_idx)

                if not success:
                    log.failure(f"Failed round {round_num}")
                    io.close()
                    break

                successful_keys.append(found_key)

                # If we completed round 5
                if round_num == 5:
                    log.success("Completed all 5 rounds!")
                    flag = io.recvall(timeout=3).decode(errors='ignore')
                    log.success(f"FLAG: {flag}")
                    io.close()
                    return

            io.close()

        except Exception as e:
            log.failure(f"Connection error: {e}")
            continue

    log.failure("Exhausted all connection attempts")

if __name__ == "__main__":
    main()
