#!/usr/bin/env python3

import os

flag = os.environ.get("FLAG", "ptm{REDACTED}")

ROUNDS = 9
GF16_POLY = 0x13 

SBOX = [
	0xC, 0x5, 0x6, 0xB, 0x9, 0x0, 0xA, 0xD,
	0x3, 0xE, 0xF, 0x8, 0x4, 0x7, 0x1, 0x2,
]

PERM = [
    [0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1],
    [0x0, 0x1, 0x2, 0x4, 0x8, 0x3, 0x6, 0xc, 0xb, 0x5, 0xa, 0x7, 0xe, 0xf, 0xd, 0x9],
    [0x0, 0x1, 0x4, 0x3, 0xc, 0x5, 0x7, 0xf, 0x9, 0x2, 0x8, 0x6, 0xb, 0xa, 0xe, 0xd],
    [0x0, 0x1, 0x8, 0xc, 0xa, 0xf, 0x1, 0x8, 0xc, 0xa, 0xf, 0x1, 0x8, 0xc, 0xa, 0xf],
    [0x0, 0x1, 0x3, 0x5, 0xf, 0x2, 0x6, 0xa, 0xd, 0x4, 0xc, 0x7, 0x9, 0x8, 0xb, 0xe],
    [0x0, 0x1, 0x6, 0x7, 0x1, 0x6, 0x7, 0x1, 0x6, 0x7, 0x1, 0x6, 0x7, 0x1, 0x6, 0x7],
    [0x0, 0x1, 0xc, 0xf, 0x8, 0xa, 0x1, 0xc, 0xf, 0x8, 0xa, 0x1, 0xc, 0xf, 0x8, 0xa],
    [0x0, 0x1, 0xb, 0x9, 0xc, 0xd, 0x6, 0xf, 0x3, 0xe, 0x8, 0x7, 0x4, 0xa, 0x2, 0x5],
    [0x0, 0x1, 0x5, 0x2, 0xa, 0x4, 0x7, 0x8, 0xe, 0x3, 0xf, 0x6, 0xd, 0xc, 0x9, 0xb],
    [0x0, 0x1, 0xa, 0x8, 0xf, 0xc, 0x1, 0xa, 0x8, 0xf, 0xc, 0x1, 0xa, 0x8, 0xf, 0xc],
    [0x0, 0x1, 0x7, 0x6, 0x1, 0x7, 0x6, 0x1, 0x7, 0x6, 0x1, 0x7, 0x6, 0x1, 0x7, 0x6],
    [0x0, 0x1, 0xe, 0xb, 0x8, 0x9, 0x7, 0xc, 0x4, 0xd, 0xa, 0x6, 0x2, 0xf, 0x5, 0x3],
    [0x0, 0x1, 0xf, 0xa, 0xc, 0x8, 0x1, 0xf, 0xa, 0xc, 0x8, 0x1, 0xf, 0xa, 0xc, 0x8],
    [0x0, 0x1, 0xd, 0xe, 0xa, 0xb, 0x6, 0x8, 0x2, 0x9, 0xf, 0x7, 0x5, 0xc, 0x3, 0x4],
    [0x0, 0x1, 0x9, 0xd, 0xf, 0xe, 0x7, 0xa, 0x5, 0xb, 0xc, 0x6, 0x3, 0x8, 0x4, 0x2],
    [0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1]
]

PERM = list(map(list, zip(*PERM)))

def encrypt_block(plaintext, master_key):
	round_keys = _derive_round_keys(master_key)

	left = int.from_bytes(plaintext[:8], "big")
	right = int.from_bytes(plaintext[8:], "big")

	for round_key in round_keys:
		left, right = right, left ^ _round_function(right, round_key)

	left, right = right, left
	return left.to_bytes(8, "big") + right.to_bytes(8, "big")

def hash(message, iv):
	state = iv
	padded = _pad_message(message)

	for offset in range(0, len(padded), 16):
		block = padded[offset:offset + 16]
		cipher_out = encrypt_block(block, state)
		state = bytes(a ^ b ^ c for a, b, c in zip(cipher_out, state, block))

	return state

def _derive_round_keys(master_key):
	key_state = int.from_bytes(master_key, "big")
	mask = (1 << 128) - 1
	round_keys = []

	for _ in range(ROUNDS):
		round_keys.append((key_state >> 64) & 0xFFFFFFFFFFFFFFFF)
		key_state = ((key_state << 7) | (key_state >> (128 - 7))) & mask

	return round_keys

def _round_function(half_block, round_key):
	state = half_block ^ round_key
	nibbles = _int_to_nibbles(state, 16)
	nibbles = [_apply_sbox(n) for n in nibbles]
	nibbles = _mix_columns(nibbles)
	return _nibbles_to_int(nibbles)

def _apply_sbox(nibble):
	return SBOX[nibble & 0xF]

def _mix_columns(nibbles):
	mixed = []
	for row in PERM:
		acc = 0
		for idx in range(16):
			acc ^= _mul(row[idx], nibbles[idx])
		mixed.append(acc)
	return mixed

def _mul(a, b):
	a &= 0xF
	b &= 0xF
	result = 0
	for _ in range(4):
		if b & 1:
			result ^= a
		b >>= 1
		carry = a & 0x8
		a = (a << 1) & 0xF
		if carry:
			a ^= (GF16_POLY & 0xF)
	return result & 0xF

def _int_to_nibbles(value, width):
	return [(value >> (4 * (width - 1 - i))) & 0xF for i in range(width)]

def _nibbles_to_int(nibbles):
	value = 0
	for nibble in nibbles:
		value = (value << 4) | (nibble & 0xF)
	return value

def _pad_message(message):
	message_length_bits = len(message) * 8
	padding = b"\x80"
	total_len = len(message) + 1
	remainder = total_len % 16
	if remainder:
		padding += b"\x00" * (16 - remainder)
	return message + padding + message_length_bits.to_bytes(16, "big")

if __name__ == "__main__":
	for _ in range(2):
		iv = os.urandom(16)
		print(f"IV: {iv.hex()}")
		a = bytes.fromhex(input("> "))
		b = bytes.fromhex(input("> "))
		ha = hash(a, iv)
		hb = hash(b, iv)
		if ha != hb or a == b:
			print("Nope!")
			exit(0)
	print(flag)